# 세션 요약 — 2026-02-23 (UX·에러 마스킹·중복 API 제거)

이 문서는 2026-02-23에 진행한 **에러 마스킹(Graceful Degradation)**, **서류 완료 버튼 반응성 개선**, **보호자 대시보드 7연속 GET 제거** 작업을 정리한 SSOT입니다.

---

## 1. 토큰 만료 시 에러 마스킹 (Error Masking)

### 배경
- 퇴원 처리 후 사용자가 브라우저 뒤로가기를 누르면, 만료된 토큰으로 `GET /dashboard` 및 WebSocket이 404/403을 받음.
- 이는 **정상적인 비즈니스 흐름**(퇴원 → 리다이렉트)인데도 `console.error`와 Next.js 에러 오버레이가 뜨며 Error Noise가 발생함.

### 원칙
- 예상된 토큰 에러(`Invalid or inactive admission token`)는 **시스템 크래시가 아닌 정상 방어**로 간주하고, **조용히 무시(Silent Graceful Degradation)**.
- `tokenInvalidatedRef`로 만료 후 추가 fetch를 선제 차단하여 불필요한 후속 상태 업데이트와 로그 폭주를 방지함.

### 수정 파일

| 파일 | 변경 내용 |
|------|------------|
| **`frontend/src/lib/api.ts`** | `!res.ok` 분기에서 `errorMsg`에 `"Invalid or inactive admission token"` 포함 시 `console.error` 및 `tauriLog('error')` 생략, `console.warn('[API] 만료된 토큰 접근 감지. 정상 리다이렉트 대기 중...')`만 출력. 에러는 그대로 `throw`하여 상위에서 처리 가능하도록 유지. |
| **`frontend/src/hooks/useVitals.ts`** | `fetchDashboardData`의 `catch` 블록 맨 앞에서 동일 메시지 포함 시 `tokenInvalidatedRef.current = true` 설정 후 `console.warn('[useVitals] 만료된 토큰에 의한 데이터 패치 중단.')`만 출력하고 `onDischarge` 또는 alert/리다이렉트 후 `return`. `appLog('error')`는 해당 경로에서 호출하지 않음. |

### 결과
- 뒤로가기 시 붉은색 콘솔 에러 및 Next.js 에러 오버레이 없이, 노란색 경고만 출력되며 리다이렉트됨.

---

## 2. 서류 완료 버튼 반응성 개선 (Fire-and-Forget + 즉시 스크롤)

### 배경
- 완료 버튼 클릭 시 `PATCH` 완료 → 500ms `setTimeout` → `GET` 대기 → 스크롤 순서로 동작하여, 사용자가 네트워크 왕복 시간 동안 멈춘 화면을 보는 렉(버벅임)이 발생함.

### 원칙
- **비동기 통신은 백그라운드(Fire-and-Forget)** 로 두고, **UI 스크롤은 통신 완료를 기다리지 않고 즉시** 실행하여 체감 대기 시간을 0에 가깝게 함.

### 수정 파일

| 파일 | 변경 내용 |
|------|------------|
| **`frontend/src/components/PatientDetailModal.tsx`** | ① `onCompleteRequest` 내부의 `await onCompleteRequest?.(...)`, `await setTimeout(500)`, `await fetchDashboardData({ force: true })` 제거. ② `onCompleteRequest?.(id, type, bed.id)?.then(() => fetchDashboardData({ force: true }))?.catch(...)` 로 백그라운드 실행. ③ `requestAnimationFrame`으로 `#patient-sidebar-completed-docs` 스크롤을 **통신 완료와 무관하게** 클릭 직후 실행. ④ 테스트용 500ms `setTimeout` 제거. |

### 결과
- 완료 버튼 클릭 즉시 요청 사항 알림이 사라지고, 오른쪽 아래 완료 영역으로 부드럽게 스크롤되며, 백그라운드에서 서류 목록이 갱신됨.

---

## 3. 보호자 대시보드 7연속 GET 제거 (초기 fetch 1회화)

### 배경
- 보호자 대시보드(또는 식단 변경 모달 열기) 시 `GET /api/v1/dashboard/{token}` 이 7번 연속 호출되는 버스트 현상이 백엔드 로그에 포착됨.
- 원인: **`useDashboardStats`** 에서 `onDischarge`를 인라인으로 넘겨 매 렌더마다 새 참조 생성 → **useVitals**의 `fetchDashboardData`가 `useCallback(..., [token, onDischarge])`로 재생성 → 초기 fetch용 **useEffect**가 `[token, enabled, fetchDashboardData]`에 의존해 `fetchDashboardData` 변경 시마다 effect 재실행 → 연쇄 GET.

### 원칙
- **의존성 안정화**: `onDischarge`를 `useCallback`으로 메모이제이션하여 `fetchDashboardData` 참조 안정화.
- **조기 차단**: token/enabled당 **초기 fetch 1회만** 실행하도록 ref 가드 도입. `fetchDashboardData`를 effect 의존성 배열에서 제외하여 부모 리렌더로 인한 연쇄 호출 방지.

### 수정 파일

| 파일 | 변경 내용 |
|------|------------|
| **`frontend/src/hooks/useDashboardStats.ts`** | `onDischarge`를 `useCallback(() => { alert(...); window.close(); setTimeout(() => router.push('/403'), 500); }, [router])`로 정의 후 `useVitals(token, true, onDischarge)`에 전달. |
| **`frontend/src/hooks/useVitals.ts`** | ① `initialFetchDoneRef` 추가. ② `token` 변경 시 `useEffect`에서 `initialFetchDoneRef.current = false`로 리셋. ③ 초기 fetch용 `useEffect`를 **token, enabled만** 의존하도록 변경하고, `initialFetchDoneRef`가 이미 true면 `fetchDashboardData()` 호출 생략. `fetchDashboardData`는 의존성 배열에서 제외(eslint-disable 주석으로 이유 명시). |

### 검증
- **MealRequestModal**: 모달 열 때 자체 대시보드 API 호출 없음. `currentMeals`는 props로만 받음.
- **식단 변경 버튼**: `onClick`은 `setIsMealModalOpen(true)`만 수행. `force: true` 리프레시는 모달 제출 성공 시 `onSuccess` → `actions.refetch()`에서만 호출됨.

### 결과
- 보호자 대시보드 진입 시 초기 1회 GET + (WebSocket onOpen 시 1회, 500ms 디바운스 내면 스킵). 식단 변경 버튼만 눌렀을 때 추가 GET 없음.

---

## 4. 스테이션 그리드 초기 로드 빈 화면 버그 (Race Condition)

### 배경
- `/station` 최초 접속 또는 퇴원 후 새로고침 시, DB에 환자 데이터가 있음에도 그리드가 빈 슬롯으로만 표시됨.
- React Strict Mode 이중 호출과 비동기 시퀀스 가드, useEffect 내 파괴적 리셋이 겹쳐 첫 번째 정상 응답이 버려지거나 그리드가 덮어쓰기됨.

### 원인 요약
1. **파괴적 리셋**: useEffect 첫 줄의 `setBeds(ROOM_NUMBERS.map(...))`가 API 응답 전·후로 그리드를 빈 슬롯으로 덮어씀.
2. **시퀀스 가드**: Strict Mode로 인해 두 번째 요청의 `requestRef`가 첫 응답 수신 시점에 우선하여, 첫 번째(실제 데이터) 응답이 "오래된 응답"으로 무시됨.
3. **캐시**: 빈 배열 응답이 캐싱되어 최초 로드 시 빈 데이터가 반환될 수 있음.

### 적용한 해결
- **백엔드**: `admissions.py` `list_admissions`에 `Cache-Control: no-cache, no-store, must-revalidate` 설정.
- **프론트**: `useStation.ts`에서 (1) 초기 상태를 `useState(emptySlotsInitial)`로만 설정하고 effect 내 리셋 제거, (2) `initialFetchDoneRef`로 마운트 시 `fetchAdmissions(true)` 1회만 실행, (3) `force=true`일 때 시퀀스 가드 우회 및 URL에 `?_t=Date.now()` 캐시 버스팅.

상세 원인·검증 절차는 **`docs/TROUBLESHOOTING.md` §12** 참고.

---

## 5. 참고

- 토큰 만료 시 클라이언트 동작 원칙은 **`docs/CRITICAL_LOGIC.md` §3.4 Token Expiration Handling** 및 본 세션의 에러 마스킹과 함께 적용됨.
- 서류 완료 후 데이터 파이프라인(DB ↔ 프론트 상태) 및 RLS 수정 이력은 **`docs/prompts/PROMPT_COMPLETED_DOCS_NOT_SHOWING.md`** 참고.
